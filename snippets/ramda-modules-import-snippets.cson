'.source.js.jsx':
  '__ :: ' :
    'prefix': 'rai___'
    'body': """
    import __ from 'ramda/__';

    """
  'Add :: Number -> Number -> Number' :
    'prefix': 'rai_add'
    'body': """
    import Add from 'ramda/add';

    """
  'Adjust :: (a -> a) -> Number -> [a] -> [a]' :
    'prefix': 'rai_adjust'
    'body': """
    import Adjust from 'ramda/adjust';

    """
  'All :: (a -> Boolean) -> [a] -> Boolean' :
    'prefix': 'rai_all'
    'body': """
    import All from 'ramda/all';

    """
  'Always :: a -> (* -> a)' :
    'prefix': 'rai_always'
    'body': """
    import Always from 'ramda/always';

    """
  'And :: * -> * -> *' :
    'prefix': 'rai_and'
    'body': """
    import And from 'ramda/and';

    """
  'Any :: (a -> Boolean) -> [a] -> Boolean' :
    'prefix': 'rai_any'
    'body': """
    import Any from 'ramda/any';

    """
  'Aperture :: Number -> [a] -> [[a]]' :
    'prefix': 'rai_aperture'
    'body': """
    import Aperture from 'ramda/aperture';

    """
  'Append :: a -> [a] -> [a]' :
    'prefix': 'rai_append'
    'body': """
    import Append from 'ramda/append';

    """
  'Apply :: (*... -> a) -> [*] -> a' :
    'prefix': 'rai_apply'
    'body': """
    import Apply from 'ramda/apply';

    """
  'Assoc :: String -> a -> {k: v} -> {k: v}' :
    'prefix': 'rai_assoc'
    'body': """
    import Assoc from 'ramda/assoc';

    """
  'AssocPath :: [String] -> a -> {k: v} -> {k: v}' :
    'prefix': 'rai_assocPath'
    'body': """
    import AssocPath from 'ramda/assocPath';

    """
  'Bind :: (* -> *) -> {*} -> (* -> *)' :
    'prefix': 'rai_bind'
    'body': """
    import Bind from 'ramda/bind';

    """
  'Clamp :: Ord a => a -> a -> a -> a' :
    'prefix': 'rai_clamp'
    'body': """
    import Clamp from 'ramda/clamp';

    """
  'Comparator :: (a, b -> Boolean) -> (a, b -> Number)' :
    'prefix': 'rai_comparator'
    'body': """
    import Comparator from 'ramda/comparator';

    """
  'CurryN :: Number -> (* -> a) -> (* -> a)' :
    'prefix': 'rai_curryN'
    'body': """
    import CurryN from 'ramda/curryN';

    """
  'Dec :: Number -> Number' :
    'prefix': 'rai_dec'
    'body': """
    import Dec from 'ramda/dec';

    """
  'DefaultTo :: a -> b -> a | b' :
    'prefix': 'rai_defaultTo'
    'body': """
    import DefaultTo from 'ramda/defaultTo';

    """
  'DifferenceWith :: (a -> a -> Boolean) -> [*] -> [*] -> [*]' :
    'prefix': 'rai_differenceWith'
    'body': """
    import DifferenceWith from 'ramda/differenceWith';

    """
  'Dissoc :: String -> {k: v} -> {k: v}' :
    'prefix': 'rai_dissoc'
    'body': """
    import Dissoc from 'ramda/dissoc';

    """
  'DissocPath :: [String] -> {k: v} -> {k: v}' :
    'prefix': 'rai_dissocPath'
    'body': """
    import DissocPath from 'ramda/dissocPath';

    """
  'Divide :: Number -> Number -> Number' :
    'prefix': 'rai_divide'
    'body': """
    import Divide from 'ramda/divide';

    """
  'DropWhile :: (a -> Boolean) -> [a] -> [a]' :
    'prefix': 'rai_dropWhile'
    'body': """
    import DropWhile from 'ramda/dropWhile';

    """
  'Empty :: a -> a' :
    'prefix': 'rai_empty'
    'body': """
    import Empty from 'ramda/empty';

    """
  'Evolve :: {k: (v -> v)} -> {k: v} -> {k: v}' :
    'prefix': 'rai_evolve'
    'body': """
    import Evolve from 'ramda/evolve';

    """
  'Find :: (a -> Boolean) -> [a] -> a | undefined' :
    'prefix': 'rai_find'
    'body': """
    import Find from 'ramda/find';

    """
  'FindIndex :: (a -> Boolean) -> [a] -> Number' :
    'prefix': 'rai_findIndex'
    'body': """
    import FindIndex from 'ramda/findIndex';

    """
  'FindLast :: (a -> Boolean) -> [a] -> a | undefined' :
    'prefix': 'rai_findLast'
    'body': """
    import FindLast from 'ramda/findLast';

    """
  'FindLastIndex :: (a -> Boolean) -> [a] -> Number' :
    'prefix': 'rai_findLastIndex'
    'body': """
    import FindLastIndex from 'ramda/findLastIndex';

    """
  'ForEach :: (a -> *) -> [a] -> [a]' :
    'prefix': 'rai_forEach'
    'body': """
    import ForEach from 'ramda/forEach';

    """
  'FromPairs :: [[k,v]] -> {k: v}' :
    'prefix': 'rai_fromPairs'
    'body': """
    import FromPairs from 'ramda/fromPairs';

    """
  'GroupWith :: (a, a -> Boolean) -> [a] -> [[a]]' :
    'prefix': 'rai_groupWith'
    'body': """
    import GroupWith from 'ramda/groupWith';

    """
  'Gt :: Ord a => a -> a -> Boolean' :
    'prefix': 'rai_gt'
    'body': """
    import Gt from 'ramda/gt';

    """
  'Gte :: Ord a => a -> a -> Boolean' :
    'prefix': 'rai_gte'
    'body': """
    import Gte from 'ramda/gte';

    """
  'Has :: s -> {s: x} -> Boolean' :
    'prefix': 'rai_has'
    'body': """
    import Has from 'ramda/has';

    """
  'HasIn :: s -> {s: x} -> Boolean' :
    'prefix': 'rai_hasIn'
    'body': """
    import HasIn from 'ramda/hasIn';

    """
  'Identical :: a -> a -> Boolean' :
    'prefix': 'rai_identical'
    'body': """
    import Identical from 'ramda/identical';

    """
  'Identity :: a -> a' :
    'prefix': 'rai_identity'
    'body': """
    import Identity from 'ramda/identity';

    """
  'IfElse :: (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)' :
    'prefix': 'rai_ifElse'
    'body': """
    import IfElse from 'ramda/ifElse';

    """
  'Inc :: Number -> Number' :
    'prefix': 'rai_inc'
    'body': """
    import Inc from 'ramda/inc';

    """
  'Insert :: Number -> a -> [a] -> [a]' :
    'prefix': 'rai_insert'
    'body': """
    import Insert from 'ramda/insert';

    """
  'InsertAll :: Number -> [a] -> [a] -> [a]' :
    'prefix': 'rai_insertAll'
    'body': """
    import InsertAll from 'ramda/insertAll';

    """
  'Intersperse :: a -> [a] -> [a]' :
    'prefix': 'rai_intersperse'
    'body': """
    import Intersperse from 'ramda/intersperse';

    """
  'Is :: (* -> {*}) -> a -> Boolean' :
    'prefix': 'rai_is'
    'body': """
    import Is from 'ramda/is';

    """
  'IsArrayLike :: * -> Boolean' :
    'prefix': 'rai_isArrayLike'
    'body': """
    import IsArrayLike from 'ramda/isArrayLike';

    """
  'IsNil :: * -> Boolean' :
    'prefix': 'rai_isNil'
    'body': """
    import IsNil from 'ramda/isNil';

    """
  'Keys :: {k: v} -> [k]' :
    'prefix': 'rai_keys'
    'body': """
    import Keys from 'ramda/keys';

    """
  'KeysIn :: {k: v} -> [k]' :
    'prefix': 'rai_keysIn'
    'body': """
    import KeysIn from 'ramda/keysIn';

    """
  'Length :: [a] -> Number' :
    'prefix': 'rai_length'
    'body': """
    import Length from 'ramda/length';

    """
  'Lt :: Ord a => a -> a -> Boolean' :
    'prefix': 'rai_lt'
    'body': """
    import Lt from 'ramda/lt';

    """
  'Lte :: Ord a => a -> a -> Boolean' :
    'prefix': 'rai_lte'
    'body': """
    import Lte from 'ramda/lte';

    """
  'MapAccum :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])' :
    'prefix': 'rai_mapAccum'
    'body': """
    import MapAccum from 'ramda/mapAccum';

    """
  'MapAccumRight :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])' :
    'prefix': 'rai_mapAccumRight'
    'body': """
    import MapAccumRight from 'ramda/mapAccumRight';

    """
  'Match :: RegExp -> String -> [String | Undefined]' :
    'prefix': 'rai_match'
    'body': """
    import Match from 'ramda/match';

    """
  'MathMod :: Number -> Number -> Number' :
    'prefix': 'rai_mathMod'
    'body': """
    import MathMod from 'ramda/mathMod';

    """
  'Max :: Ord a => a -> a -> a' :
    'prefix': 'rai_max'
    'body': """
    import Max from 'ramda/max';

    """
  'MaxBy :: Ord b => (a -> b) -> a -> a -> a' :
    'prefix': 'rai_maxBy'
    'body': """
    import MaxBy from 'ramda/maxBy';

    """
  'Merge :: {k: v} -> {k: v} -> {k: v}' :
    'prefix': 'rai_merge'
    'body': """
    import Merge from 'ramda/merge';

    """
  'MergeAll :: [{k: v}] -> {k: v}' :
    'prefix': 'rai_mergeAll'
    'body': """
    import MergeAll from 'ramda/mergeAll';

    """
  'MergeWithKey :: (String -> a -> a -> a) -> {a} -> {a} -> {a}' :
    'prefix': 'rai_mergeWithKey'
    'body': """
    import MergeWithKey from 'ramda/mergeWithKey';

    """
  'Min :: Ord a => a -> a -> a' :
    'prefix': 'rai_min'
    'body': """
    import Min from 'ramda/min';

    """
  'MinBy :: Ord b => (a -> b) -> a -> a -> a' :
    'prefix': 'rai_minBy'
    'body': """
    import MinBy from 'ramda/minBy';

    """
  'Modulo :: Number -> Number -> Number' :
    'prefix': 'rai_modulo'
    'body': """
    import Modulo from 'ramda/modulo';

    """
  'Multiply :: Number -> Number -> Number' :
    'prefix': 'rai_multiply'
    'body': """
    import Multiply from 'ramda/multiply';

    """
  'NAry :: Number -> (* -> a) -> (* -> a)' :
    'prefix': 'rai_nAry'
    'body': """
    import NAry from 'ramda/nAry';

    """
  'Negate :: Number -> Number' :
    'prefix': 'rai_negate'
    'body': """
    import Negate from 'ramda/negate';

    """
  'None :: (a -> Boolean) -> [a] -> Boolean' :
    'prefix': 'rai_none'
    'body': """
    import None from 'ramda/none';

    """
  'Not :: * -> Boolean' :
    'prefix': 'rai_not'
    'body': """
    import Not from 'ramda/not';

    """
  'Nth :: Number -> [a] -> a | Undefined' :
    'prefix': 'rai_nth'
    'body': """
    import Nth from 'ramda/nth';

    """
  'NthArg :: Number -> *... -> *' :
    'prefix': 'rai_nthArg'
    'body': """
    import NthArg from 'ramda/nthArg';

    """
  'ObjOf :: String -> a -> {String:a}' :
    'prefix': 'rai_objOf'
    'body': """
    import ObjOf from 'ramda/objOf';

    """
  'Of :: a -> [a]' :
    'prefix': 'rai_of'
    'body': """
    import Of from 'ramda/of';

    """
  'Once :: (a... -> b) -> (a... -> b)' :
    'prefix': 'rai_once'
    'body': """
    import Once from 'ramda/once';

    """
  'Or :: * -> * -> *' :
    'prefix': 'rai_or'
    'body': """
    import Or from 'ramda/or';

    """
  'Over :: Lens s a -> (a -> a) -> s -> s' :
    'prefix': 'rai_over'
    'body': """
    import Over from 'ramda/over';

    """
  'Pair :: a -> b -> (a,b)' :
    'prefix': 'rai_pair'
    'body': """
    import Pair from 'ramda/pair';

    """
  'Path :: [String] -> {k: v} -> v | Undefined' :
    'prefix': 'rai_path'
    'body': """
    import Path from 'ramda/path';

    """
  'PathOr :: a -> [String] -> Object -> a' :
    'prefix': 'rai_pathOr'
    'body': """
    import PathOr from 'ramda/pathOr';

    """
  'PathSatisfies :: (a -> Boolean) -> [String] -> Object -> Boolean' :
    'prefix': 'rai_pathSatisfies'
    'body': """
    import PathSatisfies from 'ramda/pathSatisfies';

    """
  'Pick :: [k] -> {k: v} -> {k: v}' :
    'prefix': 'rai_pick'
    'body': """
    import Pick from 'ramda/pick';

    """
  'PickAll :: [k] -> {k: v} -> {k: v}' :
    'prefix': 'rai_pickAll'
    'body': """
    import PickAll from 'ramda/pickAll';

    """
  'PickBy :: (v, k -> Boolean) -> {k: v} -> {k: v}' :
    'prefix': 'rai_pickBy'
    'body': """
    import PickBy from 'ramda/pickBy';

    """
  'Prepend :: a -> [a] -> [a]' :
    'prefix': 'rai_prepend'
    'body': """
    import Prepend from 'ramda/prepend';

    """
  'Prop :: s -> {s: a} -> a | Undefined' :
    'prefix': 'rai_prop'
    'body': """
    import Prop from 'ramda/prop';

    """
  'PropOr :: a -> String -> Object -> a' :
    'prefix': 'rai_propOr'
    'body': """
    import PropOr from 'ramda/propOr';

    """
  'PropSatisfies :: (a -> Boolean) -> String -> {String: a} -> Boolean' :
    'prefix': 'rai_propSatisfies'
    'body': """
    import PropSatisfies from 'ramda/propSatisfies';

    """
  'Props :: [k] -> {k: v} -> [v]' :
    'prefix': 'rai_props'
    'body': """
    import Props from 'ramda/props';

    """
  'Range :: Number -> Number -> [Number]' :
    'prefix': 'rai_range'
    'body': """
    import Range from 'ramda/range';

    """
  'ReduceRight :: (a,b -> a) -> a -> [b] -> a' :
    'prefix': 'rai_reduceRight'
    'body': """
    import ReduceRight from 'ramda/reduceRight';

    """
  'Reduced :: a -> *' :
    'prefix': 'rai_reduced'
    'body': """
    import Reduced from 'ramda/reduced';

    """
  'Remove :: Number -> Number -> [a] -> [a]' :
    'prefix': 'rai_remove'
    'body': """
    import Remove from 'ramda/remove';

    """
  'Replace :: RegExp|String -> String -> String -> String' :
    'prefix': 'rai_replace'
    'body': """
    import Replace from 'ramda/replace';

    """
  'Reverse :: [a] -> [a]' :
    'prefix': 'rai_reverse'
    'body': """
    import Reverse from 'ramda/reverse';

    """
  'Scan :: (a,b -> a) -> a -> [b] -> [a]' :
    'prefix': 'rai_scan'
    'body': """
    import Scan from 'ramda/scan';

    """
  'Set :: Lens s a -> a -> s -> s' :
    'prefix': 'rai_set'
    'body': """
    import Set from 'ramda/set';

    """
  'Slice :: Number -> Number -> [a] -> [a]' :
    'prefix': 'rai_slice'
    'body': """
    import Slice from 'ramda/slice';

    """
  'Sort :: (a,a -> Number) -> [a] -> [a]' :
    'prefix': 'rai_sort'
    'body': """
    import Sort from 'ramda/sort';

    """
  'SortBy :: Ord b => (a -> b) -> [a] -> [a]' :
    'prefix': 'rai_sortBy'
    'body': """
    import SortBy from 'ramda/sortBy';

    """
  'SplitAt :: Number -> [a] -> [[a], [a]]' :
    'prefix': 'rai_splitAt'
    'body': """
    import SplitAt from 'ramda/splitAt';

    """
  'SplitEvery :: Number -> [a] -> [[a]]' :
    'prefix': 'rai_splitEvery'
    'body': """
    import SplitEvery from 'ramda/splitEvery';

    """
  'SplitWhen :: (a -> Boolean) -> [a] -> [[a], [a]]' :
    'prefix': 'rai_splitWhen'
    'body': """
    import SplitWhen from 'ramda/splitWhen';

    """
  'Subtract :: Number -> Number -> Number' :
    'prefix': 'rai_subtract'
    'body': """
    import Subtract from 'ramda/subtract';

    """
  'Tail :: [a] -> [a]' :
    'prefix': 'rai_tail'
    'body': """
    import Tail from 'ramda/tail';

    """
  'Take :: Number -> [a] -> [a]' :
    'prefix': 'rai_take'
    'body': """
    import Take from 'ramda/take';

    """
  'TakeLastWhile :: (a -> Boolean) -> [a] -> [a]' :
    'prefix': 'rai_takeLastWhile'
    'body': """
    import TakeLastWhile from 'ramda/takeLastWhile';

    """
  'TakeWhile :: (a -> Boolean) -> [a] -> [a]' :
    'prefix': 'rai_takeWhile'
    'body': """
    import TakeWhile from 'ramda/takeWhile';

    """
  'Tap :: (a -> *) -> a -> a' :
    'prefix': 'rai_tap'
    'body': """
    import Tap from 'ramda/tap';

    """
  'Times :: (Number -> a) -> Number -> [a]' :
    'prefix': 'rai_times'
    'body': """
    import Times from 'ramda/times';

    """
  'ToPairs :: {String: *} -> [[String,*]]' :
    'prefix': 'rai_toPairs'
    'body': """
    import ToPairs from 'ramda/toPairs';

    """
  'ToPairsIn :: {String: *} -> [[String,*]]' :
    'prefix': 'rai_toPairsIn'
    'body': """
    import ToPairsIn from 'ramda/toPairsIn';

    """
  'Transpose :: [[a]] -> [[a]]' :
    'prefix': 'rai_transpose'
    'body': """
    import Transpose from 'ramda/transpose';

    """
  'Trim :: String -> String' :
    'prefix': 'rai_trim'
    'body': """
    import Trim from 'ramda/trim';

    """
  'TryCatch :: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)' :
    'prefix': 'rai_tryCatch'
    'body': """
    import TryCatch from 'ramda/tryCatch';

    """
  'Type :: (* -> {*}) -> String' :
    'prefix': 'rai_type'
    'body': """
    import Type from 'ramda/type';

    """
  'Unapply :: ([*...] -> a) -> (*... -> a)' :
    'prefix': 'rai_unapply'
    'body': """
    import Unapply from 'ramda/unapply';

    """
  'Unary :: (* -> b) -> (a -> b)' :
    'prefix': 'rai_unary'
    'body': """
    import Unary from 'ramda/unary';

    """
  'UncurryN :: Number -> (a -> b) -> (a -> c)' :
    'prefix': 'rai_uncurryN'
    'body': """
    import UncurryN from 'ramda/uncurryN';

    """
  'Unfold :: (a -> [b]) -> * -> [b]' :
    'prefix': 'rai_unfold'
    'body': """
    import Unfold from 'ramda/unfold';

    """
  'UniqWith :: (a, a -> Boolean) -> [a] -> [a]' :
    'prefix': 'rai_uniqWith'
    'body': """
    import UniqWith from 'ramda/uniqWith';

    """
  'Unless :: (a -> Boolean) -> (a -> a) -> a -> a' :
    'prefix': 'rai_unless'
    'body': """
    import Unless from 'ramda/unless';

    """
  'Until :: (a -> Boolean) -> (a -> a) -> a -> a' :
    'prefix': 'rai_until'
    'body': """
    import Until from 'ramda/until';

    """
  'Update :: Number -> a -> [a] -> [a]' :
    'prefix': 'rai_update'
    'body': """
    import Update from 'ramda/update';

    """
  'UseWith :: (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)' :
    'prefix': 'rai_useWith'
    'body': """
    import UseWith from 'ramda/useWith';

    """
  'Values :: {k: v} -> [v]' :
    'prefix': 'rai_values'
    'body': """
    import Values from 'ramda/values';

    """
  'ValuesIn :: {k: v} -> [v]' :
    'prefix': 'rai_valuesIn'
    'body': """
    import ValuesIn from 'ramda/valuesIn';

    """
  'View :: Lens s a -> s -> a' :
    'prefix': 'rai_view'
    'body': """
    import View from 'ramda/view';

    """
  'When :: (a -> Boolean) -> (a -> a) -> a -> a' :
    'prefix': 'rai_when'
    'body': """
    import When from 'ramda/when';

    """
  'Where :: {String: (* -> Boolean)} -> {String: *} -> Boolean' :
    'prefix': 'rai_where'
    'body': """
    import Where from 'ramda/where';

    """
  'Wrap :: (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)' :
    'prefix': 'rai_wrap'
    'body': """
    import Wrap from 'ramda/wrap';

    """
  'Xprod :: [a] -> [b] -> [[a,b]]' :
    'prefix': 'rai_xprod'
    'body': """
    import Xprod from 'ramda/xprod';

    """
  'Zip :: [a] -> [b] -> [[a,b]]' :
    'prefix': 'rai_zip'
    'body': """
    import Zip from 'ramda/zip';

    """
  'ZipObj :: [String] -> [*] -> {String: *}' :
    'prefix': 'rai_zipObj'
    'body': """
    import ZipObj from 'ramda/zipObj';

    """
  'ZipWith :: (a,b -> c) -> [a] -> [b] -> [c]' :
    'prefix': 'rai_zipWith'
    'body': """
    import ZipWith from 'ramda/zipWith';

    """
  'F :: * -> Boolean' :
    'prefix': 'rai_F'
    'body': """
    import F from 'ramda/F';

    """
  'T :: * -> Boolean' :
    'prefix': 'rai_T'
    'body': """
    import T from 'ramda/T';

    """
  'AddIndex :: ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)' :
    'prefix': 'rai_addIndex'
    'body': """
    import AddIndex from 'ramda/addIndex';

    """
  'Binary :: (* -> c) -> (a, b -> c)' :
    'prefix': 'rai_binary'
    'body': """
    import Binary from 'ramda/binary';

    """
  'Clone :: {*} -> {*}' :
    'prefix': 'rai_clone'
    'body': """
    import Clone from 'ramda/clone';

    """
  'Curry :: (* -> a) -> (* -> a)' :
    'prefix': 'rai_curry'
    'body': """
    import Curry from 'ramda/curry';

    """
  'Drop :: Number -> [a] -> [a]' :
    'prefix': 'rai_drop'
    'body': """
    import Drop from 'ramda/drop';

    """
  'DropLast :: Number -> [a] -> [a]' :
    'prefix': 'rai_dropLast'
    'body': """
    import DropLast from 'ramda/dropLast';

    """
  'DropLastWhile :: (a -> Boolean) -> [a] -> [a]' :
    'prefix': 'rai_dropLastWhile'
    'body': """
    import DropLastWhile from 'ramda/dropLastWhile';

    """
  'Equals :: a -> b -> Boolean' :
    'prefix': 'rai_equals'
    'body': """
    import Equals from 'ramda/equals';

    """
  'Filter :: Filterable f => (a -> Boolean) -> f a -> f a' :
    'prefix': 'rai_filter'
    'body': """
    import Filter from 'ramda/filter';

    """
  'Flatten :: [a] -> [b]' :
    'prefix': 'rai_flatten'
    'body': """
    import Flatten from 'ramda/flatten';

    """
  'Flip :: (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)' :
    'prefix': 'rai_flip'
    'body': """
    import Flip from 'ramda/flip';

    """
  'Head :: [a] -> a | Undefined' :
    'prefix': 'rai_head'
    'body': """
    import Head from 'ramda/head';

    """
  'Init :: [a] -> [a]' :
    'prefix': 'rai_init'
    'body': """
    import Init from 'ramda/init';

    """
  'IntersectionWith :: (a -> a -> Boolean) -> [*] -> [*] -> [*]' :
    'prefix': 'rai_intersectionWith'
    'body': """
    import IntersectionWith from 'ramda/intersectionWith';

    """
  'Into :: a -> (b -> b) -> [c] -> a' :
    'prefix': 'rai_into'
    'body': """
    import Into from 'ramda/into';

    """
  'Invert :: {s: x} -> {x: [ s, ... ]}' :
    'prefix': 'rai_invert'
    'body': """
    import Invert from 'ramda/invert';

    """
  'InvertObj :: {s: x} -> {x: s}' :
    'prefix': 'rai_invertObj'
    'body': """
    import InvertObj from 'ramda/invertObj';

    """
  'IsEmpty :: a -> Boolean' :
    'prefix': 'rai_isEmpty'
    'body': """
    import IsEmpty from 'ramda/isEmpty';

    """
  'Last :: [a] -> a | Undefined' :
    'prefix': 'rai_last'
    'body': """
    import Last from 'ramda/last';

    """
  'LastIndexOf :: a -> [a] -> Number' :
    'prefix': 'rai_lastIndexOf'
    'body': """
    import LastIndexOf from 'ramda/lastIndexOf';

    """
  'Map :: Functor f => (a -> b) -> f a -> f b' :
    'prefix': 'rai_map'
    'body': """
    import Map from 'ramda/map';

    """
  'MapObjIndexed :: ((*, String, Object) -> *) -> Object -> Object' :
    'prefix': 'rai_mapObjIndexed'
    'body': """
    import MapObjIndexed from 'ramda/mapObjIndexed';

    """
  'MergeWith :: (a -> a -> a) -> {a} -> {a} -> {a}' :
    'prefix': 'rai_mergeWith'
    'body': """
    import MergeWith from 'ramda/mergeWith';

    """
  'Partial :: ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)' :
    'prefix': 'rai_partial'
    'body': """
    import Partial from 'ramda/partial';

    """
  'PartialRight :: ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)' :
    'prefix': 'rai_partialRight'
    'body': """
    import PartialRight from 'ramda/partialRight';

    """
  'PathEq :: [String] -> * -> {String: *} -> Boolean' :
    'prefix': 'rai_pathEq'
    'body': """
    import PathEq from 'ramda/pathEq';

    """
  'Pluck :: k -> [{k: v}] -> [v]' :
    'prefix': 'rai_pluck'
    'body': """
    import Pluck from 'ramda/pluck';

    """
  'Project :: [k] -> [{k: v}] -> [{k: v}]' :
    'prefix': 'rai_project'
    'body': """
    import Project from 'ramda/project';

    """
  'PropEq :: String -> a -> Object -> Boolean' :
    'prefix': 'rai_propEq'
    'body': """
    import PropEq from 'ramda/propEq';

    """
  'PropIs :: Type -> String -> Object -> Boolean' :
    'prefix': 'rai_propIs'
    'body': """
    import PropIs from 'ramda/propIs';

    """
  'Reduce :: ((a, b) -> a) -> a -> [b] -> a' :
    'prefix': 'rai_reduce'
    'body': """
    import Reduce from 'ramda/reduce';

    """
  'ReduceBy :: ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}' :
    'prefix': 'rai_reduceBy'
    'body': """
    import ReduceBy from 'ramda/reduceBy';

    """
  'Reject :: Filterable f => (a -> Boolean) -> f a -> f a' :
    'prefix': 'rai_reject'
    'body': """
    import Reject from 'ramda/reject';

    """
  'Repeat :: a -> n -> [a]' :
    'prefix': 'rai_repeat'
    'body': """
    import Repeat from 'ramda/repeat';

    """
  'Sum :: [Number] -> Number' :
    'prefix': 'rai_sum'
    'body': """
    import Sum from 'ramda/sum';

    """
  'TakeLast :: Number -> [a] -> [a]' :
    'prefix': 'rai_takeLast'
    'body': """
    import TakeLast from 'ramda/takeLast';

    """
  'Transduce :: (c -> c) -> (a,b -> a) -> a -> [b] -> a' :
    'prefix': 'rai_transduce'
    'body': """
    import Transduce from 'ramda/transduce';

    """
  'UnionWith :: (a -> a -> Boolean) -> [*] -> [*] -> [*]' :
    'prefix': 'rai_unionWith'
    'body': """
    import UnionWith from 'ramda/unionWith';

    """
  'WhereEq :: {String: *} -> {String: *} -> Boolean' :
    'prefix': 'rai_whereEq'
    'body': """
    import WhereEq from 'ramda/whereEq';

    """
  'AllPass :: [(*... -> Boolean)] -> (*... -> Boolean)' :
    'prefix': 'rai_allPass'
    'body': """
    import AllPass from 'ramda/allPass';

    """
  'AllUniq :: [a] -> Boolean' :
    'prefix': 'rai_allUniq'
    'body': """
    import AllUniq from 'ramda/allUniq';

    """
  'AnyPass :: [(*... -> Boolean)] -> (*... -> Boolean)' :
    'prefix': 'rai_anyPass'
    'body': """
    import AnyPass from 'ramda/anyPass';

    """
  'Ap :: [f] -> [a] -> [f a]' :
    'prefix': 'rai_ap'
    'body': """
    import Ap from 'ramda/ap';

    """
  'ApplySpec :: {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})' :
    'prefix': 'rai_applySpec'
    'body': """
    import ApplySpec from 'ramda/applySpec';

    """
  'Call :: (*... -> a),*... -> a' :
    'prefix': 'rai_call'
    'body': """
    import Call from 'ramda/call';

    """
  'Chain :: (a -> [b]) -> [a] -> [b]' :
    'prefix': 'rai_chain'
    'body': """
    import Chain from 'ramda/chain';

    """
  'Cond :: [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)' :
    'prefix': 'rai_cond'
    'body': """
    import Cond from 'ramda/cond';

    """
  'ConstructN :: Number -> (* -> {*}) -> (* -> {*})' :
    'prefix': 'rai_constructN'
    'body': """
    import ConstructN from 'ramda/constructN';

    """
  'Converge :: (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)' :
    'prefix': 'rai_converge'
    'body': """
    import Converge from 'ramda/converge';

    """
  'CountBy :: (a -> String) -> [a] -> {*}' :
    'prefix': 'rai_countBy'
    'body': """
    import CountBy from 'ramda/countBy';

    """
  'DropRepeatsWith :: (a, a -> Boolean) -> [a] -> [a]' :
    'prefix': 'rai_dropRepeatsWith'
    'body': """
    import DropRepeatsWith from 'ramda/dropRepeatsWith';

    """
  'EqBy :: (a -> b) -> a -> a -> Boolean' :
    'prefix': 'rai_eqBy'
    'body': """
    import EqBy from 'ramda/eqBy';

    """
  'EqProps :: k -> {k: v} -> {k: v} -> Boolean' :
    'prefix': 'rai_eqProps'
    'body': """
    import EqProps from 'ramda/eqProps';

    """
  'GroupBy :: (a -> String) -> [a] -> {String: [a]}' :
    'prefix': 'rai_groupBy'
    'body': """
    import GroupBy from 'ramda/groupBy';

    """
  'IndexBy :: (a -> String) -> [{k: v}] -> {k: {k: v}}' :
    'prefix': 'rai_indexBy'
    'body': """
    import IndexBy from 'ramda/indexBy';

    """
  'IndexOf :: a -> [a] -> Number' :
    'prefix': 'rai_indexOf'
    'body': """
    import IndexOf from 'ramda/indexOf';

    """
  'Juxt :: [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])' :
    'prefix': 'rai_juxt'
    'body': """
    import Juxt from 'ramda/juxt';

    """
  'Lens :: (s -> a) -> ((a, s) -> s) -> Lens s a' :
    'prefix': 'rai_lens'
    'body': """
    import Lens from 'ramda/lens';

    """
  'LensIndex :: Number -> Lens s a' :
    'prefix': 'rai_lensIndex'
    'body': """
    import LensIndex from 'ramda/lensIndex';

    """
  'LensPath :: [String] -> Lens s a' :
    'prefix': 'rai_lensPath'
    'body': """
    import LensPath from 'ramda/lensPath';

    """
  'LensProp :: String -> Lens s a' :
    'prefix': 'rai_lensProp'
    'body': """
    import LensProp from 'ramda/lensProp';

    """
  'LiftN :: Number -> (*... -> *) -> ([*]... -> [*])' :
    'prefix': 'rai_liftN'
    'body': """
    import LiftN from 'ramda/liftN';

    """
  'Mean :: [Number] -> Number' :
    'prefix': 'rai_mean'
    'body': """
    import Mean from 'ramda/mean';

    """
  'Median :: [Number] -> Number' :
    'prefix': 'rai_median'
    'body': """
    import Median from 'ramda/median';

    """
  'Partition :: Filterable f => (a -> Boolean) -> f a -> [f a, f a]' :
    'prefix': 'rai_partition'
    'body': """
    import Partition from 'ramda/partition';

    """
  'Pipe :: (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)' :
    'prefix': 'rai_pipe'
    'body': """
    import Pipe from 'ramda/pipe';

    """
  'PipeP :: ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)' :
    'prefix': 'rai_pipeP'
    'body': """
    import PipeP from 'ramda/pipeP';

    """
  'Product :: [Number] -> Number' :
    'prefix': 'rai_product'
    'body': """
    import Product from 'ramda/product';

    """
  'Sequence :: (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)' :
    'prefix': 'rai_sequence'
    'body': """
    import Sequence from 'ramda/sequence';

    """
  'Traverse :: (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)' :
    'prefix': 'rai_traverse'
    'body': """
    import Traverse from 'ramda/traverse';

    """
  'Unnest :: Chain c => c (c a) -> c a' :
    'prefix': 'rai_unnest'
    'body': """
    import Unnest from 'ramda/unnest';

    """
  'Compose :: ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)' :
    'prefix': 'rai_compose'
    'body': """
    import Compose from 'ramda/compose';

    """
  'ComposeK :: Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)' :
    'prefix': 'rai_composeK'
    'body': """
    import ComposeK from 'ramda/composeK';

    """
  'ComposeP :: ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)' :
    'prefix': 'rai_composeP'
    'body': """
    import ComposeP from 'ramda/composeP';

    """
  'Construct :: (* -> {*}) -> (* -> {*})' :
    'prefix': 'rai_construct'
    'body': """
    import Construct from 'ramda/construct';

    """
  'Contains :: a -> [a] -> Boolean' :
    'prefix': 'rai_contains'
    'body': """
    import Contains from 'ramda/contains';

    """
  'Difference :: [*] -> [*] -> [*]' :
    'prefix': 'rai_difference'
    'body': """
    import Difference from 'ramda/difference';

    """
  'DropRepeats :: [a] -> [a]' :
    'prefix': 'rai_dropRepeats'
    'body': """
    import DropRepeats from 'ramda/dropRepeats';

    """
  'Lift :: (*... -> *) -> ([*]... -> [*])' :
    'prefix': 'rai_lift'
    'body': """
    import Lift from 'ramda/lift';

    """
  'Omit :: [String] -> {String: *} -> {String: *}' :
    'prefix': 'rai_omit'
    'body': """
    import Omit from 'ramda/omit';

    """
  'PipeK :: Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)' :
    'prefix': 'rai_pipeK'
    'body': """
    import PipeK from 'ramda/pipeK';

    """
  'ToString :: * -> String' :
    'prefix': 'rai_toString'
    'body': """
    import ToString from 'ramda/toString';

    """
  'Without :: [a] -> [a] -> [a]' :
    'prefix': 'rai_without'
    'body': """
    import Without from 'ramda/without';

    """
  'Both :: (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)' :
    'prefix': 'rai_both'
    'body': """
    import Both from 'ramda/both';

    """
  'Complement :: (*... -> *) -> (*... -> Boolean)' :
    'prefix': 'rai_complement'
    'body': """
    import Complement from 'ramda/complement';

    """
  'Either :: (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)' :
    'prefix': 'rai_either'
    'body': """
    import Either from 'ramda/either';

    """
  'Invoker :: Number -> String -> (a -> b -> ... -> n -> Object -> *)' :
    'prefix': 'rai_invoker'
    'body': """
    import Invoker from 'ramda/invoker';

    """
  'Join :: String -> [a] -> String' :
    'prefix': 'rai_join'
    'body': """
    import Join from 'ramda/join';

    """
  'Memoize :: (*... -> a) -> (*... -> a)' :
    'prefix': 'rai_memoize'
    'body': """
    import Memoize from 'ramda/memoize';

    """
  'Split :: (String | RegExp) -> String -> [String]' :
    'prefix': 'rai_split'
    'body': """
    import Split from 'ramda/split';

    """
  'Test :: RegExp -> String -> Boolean' :
    'prefix': 'rai_test'
    'body': """
    import Test from 'ramda/test';

    """
  'ToLower :: String -> String' :
    'prefix': 'rai_toLower'
    'body': """
    import ToLower from 'ramda/toLower';

    """
  'ToUpper :: String -> String' :
    'prefix': 'rai_toUpper'
    'body': """
    import ToUpper from 'ramda/toUpper';

    """
  'UniqBy :: (a -> b) -> [a] -> [a]' :
    'prefix': 'rai_uniqBy'
    'body': """
    import UniqBy from 'ramda/uniqBy';

    """
  'Concat :: [a] -> [a] -> [a]' :
    'prefix': 'rai_concat'
    'body': """
    import Concat from 'ramda/concat';

    """
  'SymmetricDifference :: [*] -> [*] -> [*]' :
    'prefix': 'rai_symmetricDifference'
    'body': """
    import SymmetricDifference from 'ramda/symmetricDifference';

    """
  'SymmetricDifferenceWith :: (a -> a -> Boolean) -> [a] -> [a] -> [a]' :
    'prefix': 'rai_symmetricDifferenceWith'
    'body': """
    import SymmetricDifferenceWith from 'ramda/symmetricDifferenceWith';

    """
  'Uniq :: [a] -> [a]' :
    'prefix': 'rai_uniq'
    'body': """
    import Uniq from 'ramda/uniq';

    """
  'Intersection :: [*] -> [*] -> [*]' :
    'prefix': 'rai_intersection'
    'body': """
    import Intersection from 'ramda/intersection';

    """
  'Union :: [*] -> [*] -> [*]' :
    'prefix': 'rai_union'
    'body': """
    import Union from 'ramda/union';

    """
